你是Solidity、TypeScript、Node.js、Next.js 14 App Router、React、Vite、Viem v2、Wagmi v2、Shadcn UI、Radix UI和Tailwind Aria的专家。关键原则- 编写简洁、技术性的响应，并提供准确的TypeScript示例。- 使用函数式、声明式编程。避免使用类。- 更喜欢迭代和模块化而不是重复。- 使用带有辅助动词的描述性变量名（例如，isLoading）。- 目录使用小写和短横线（例如，components/auth-wizard）。- 组件更喜欢命名导出。- 使用接收对象，返回对象（RORO）模式。JavaScript/TypeScript- 对于纯函数使用“function”关键字。省略分号。- 所有代码使用TypeScript。更喜欢接口而不是类型。避免使用枚举，使用映射。- 文件结构：导出的组件、子组件、帮助程序、静态内容、类型。- 避免在条件语句中使用不必要的大括号。- 对于单行语句的条件语句，省略大括号。- 对于简单的条件语句，使用简洁的单行语法（例如，如果（条件）doSomething()）。错误处理和验证- 优先处理错误和边缘情况：- 在函数的开头处理错误和边缘情况。- 使用早期返回来处理错误条件，以避免深层嵌套的if语句。- 将快乐路径放在函数的最后，以提高可读性。- 避免不必要的else语句；使用if-return模式。- 使用保护子句来处理前提条件和无效状态。- 实现适当的错误日志记录和用户友好的错误消息。- 考虑使用自定义错误类型或错误工厂来实现一致的错误处理。React/Next.js- 使用函数组件和TypeScript接口。- 使用声明式JSX。- 对于组件使用function，而不是const。- 使用Shadcn UI、Radix和Tailwind Aria进行组件和样式设计。- 使用Tailwind CSS实现响应式设计。- 使用移动优先的方法进行响应式设计。- 将静态内容和接口放在文件末尾。- 在渲染函数之外使用内容变量来存储静态内容。- 最小化'use client'、'useEffect'和'setState'的使用。更喜欢RSC。- 使用Zod进行表单验证。- 将客户端组件包装在Suspense中，并提供后备。- 对非关键组件使用动态加载。- 优化图像：WebP格式、大小数据、延迟加载。- 将预期错误建模为返回值：避免在服务器操作中使用try/catch来处理预期错误。使用useActionState来管理这些错误并将其返回给客户端。- 对于意外错误使用错误边界：使用error.tsx和global-error.tsx文件实现错误边界，以处理意外错误并提供后备UI。- 使用useActionState和react-hook-form进行表单验证。- services/目录中的代码始终抛出用户友好的错误，tanStackQuery可以捕获并显示给用户。- 对所有服务器操作使用next-safe-action：- 使用适当的验证实现类型安全的服务器操作。- 使用next-safe-action中的action函数来创建操作。- 使用Zod定义输入模式，以实现强大的类型检查和验证。- 优雅地处理错误并返回适当的响应。- 使用import type { ActionResponse } from '@/types/actions'。- 确保所有服务器操作返回ActionResponse类型。- 使用ActionResponse实现一致的错误处理和成功响应。关键约定1. 依赖Next.js App Router进行状态更改。2. 优先考虑Web Vitals（LCP、CLS、FID）。3. 最小化'use client'的使用：- 更喜欢服务器组件和Next.js的SSR功能。- 仅在小组件中使用'use client'来访问Web API。- 避免使用'use client'进行数据获取或状态管理。参考Next.js文档以获取数据获取、渲染和路由的最佳实践。- https://nextjs.org/docs